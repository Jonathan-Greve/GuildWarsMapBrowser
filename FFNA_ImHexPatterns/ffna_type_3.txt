#include <std/core.pat>
#pragma pattern_limit 1000000
#pragma array_limit 1000000
struct MapBounds {
  float map_min_x;
  float map_min_y;
  float map_max_x;
  float map_max_y;
};

struct Chunk1 {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// Map params
struct Chunk2 {
  u32 chunk_id;
  u32 chunk_size;
  // Chunk data start
  u32 magic_num;
  u8 always_2;
  MapBounds map_bounds;
  u32 f0;
  u32 f1;
  u32 f2;
  u32 f3;
  u32 f4;
};

struct Vertex2 {
  float x;
  float y;
};

struct PropInfo {
  u16 filename_index;
  float x;
  float y;
  float z;
  float f4;
  float f5;
  float f6;
  float sin_angle; // sin of angle in radians
  float cos_angle; // cos of angle in radians
  float f9;
  float scaling_factor;
  float f11;
  u8 f12;
  u8 num_some_structs;
  Vertex2 some_structs[num_some_structs];
};

struct PropArray{
  u16 num_props;
  PropInfo props_info[num_props];
};

struct SomeVertex{
  float x;
  float y;
  float z;
  u32 f6;
  u32 f7;
  u32 f8;
};



struct SomeVertexData {
  u8 f0;
  u32 array_size_in_bytes;
  u32 num_elements;
  SomeVertex vertices[num_elements];
};

struct SomeData {
  u8 f0;
  u32 array_size_in_bytes;
  u32 num_elements;
  u16 array[num_elements];
};

struct SomeData1 {
  u8 f0;
  u32 array_size_in_bytes;
  u32 num_elements;
  Vertex2 array[num_elements];
};

struct SomeData2Struct {
  u16 f0;
  u16 prop_index;
};

struct SomeData2 {
  u8 f0;
  u32 array_size_in_bytes;
  u16 num_elements;
  SomeData2Struct array[num_elements];
};

struct Chunk3 {
  u32 chunk_id;
  u32 chunk_size;
  // Chunk data start
  u32 magic_number;
  u16 magic_number2; // checked if 0x11 or 0x12 in-game.
  u32 prop_array_size_in_bytes;
  PropArray prop_array;
  SomeVertexData some_vertex_data;
  SomeData some_data0;
  SomeData1 some_data1;
  SomeData2 some_data2;
  u8 chunk_data[chunk_size-10-sizeof(prop_array)-sizeof(some_vertex_data)-sizeof(some_data0)-sizeof(some_data1)-sizeof(some_data2)];
};

struct Chunk4DataHeader { 
  u32 signature;
  u8 version;
};

// To get file hash from name do:
// (id0 - 0xff00ff) + (id2 * 0xff00);
struct FileName{
  u16 id0;
  u16 id1;
};

struct Chunk4DataElement{
  FileName filename;
  u16 f1;
};

struct Chunk4 {
  u32 chunk_id;
  u32 chunk_size;
  Chunk4DataHeader data_header;
  //Chunk4DataElement array[228];
  Chunk4DataElement array[(chunk_size-sizeof(data_header))/6];
  u8 chunk_data[chunk_size-sizeof(data_header)-sizeof(array)];
};

struct Chunk5Element{
  u8 tag;
  u16 size;
  u16 unknown;
  u8 data[size];
};

struct Chunk5Element1{
  u8 tag;
  u32 size;
  u32 num_zones;
};

struct Chunk5Element2{
  u8 unknown[20];
  u8 unknown1;
  u16 some_size;
  u16 unknown2;
  if (some_size <= 0){
    u32 unknown3;
    u32 count2;
    Vertex2 vertices[count2];
  } else{
    u8 some_data[some_size];
  }
};

struct Chunk5Sub0 {
  u32 num_vertices;
  Vertex2 vertices[num_vertices];
  u8 some_data[28];
  u8 zero;
};

struct Chunk5 {
  u32 chunk_id;
  u32 chunk_size;
  // Data start
  u32 magic_num; // 0x59220329
  u32 magic_num1; // 0xA0
  Chunk5Element element_0;
  Chunk5Element element_1;
  Chunk5Element1 element_2;
  Chunk5Element element_3;
  if (element_2.num_zones > 0){
    u32 unknown0;
    u32 unknown1;
    float unknown2[8];
    Chunk5Element2 some_array[element_2.num_zones];
    u8 chunk_data[chunk_size-8-sizeof(element_0)-sizeof(element_1)-
      sizeof(element_2)-sizeof(element_3)-8-sizeof(unknown2)-sizeof(some_array)];
  }
  else {
    u8 chunk_data[chunk_size-8-sizeof(element_0)-sizeof(element_1)-sizeof(element_2)-sizeof(element_3)];
  }
};

struct Chunk5_0 {
  u32 chunk_id;
  u32 chunk_size;
  // Data start
  u32 magic_num; // 0x59220329
  u32 magic_num1; // 0xA0
  Chunk5Element element_0;
  Chunk5Element element_1;
  Chunk5Element1 element_2;
  Chunk5Element element_3;
  if (element_2.num_zones > 0){
    u32 unknown0;
    Chunk5Sub0 sub0[element_2.num_zones];
    //u32 unknown1;
    //float unknown2[unknown1 * 2];
    //Chunk5Element2 some_array[13];
    u8 chunk_data[chunk_size-8-sizeof(element_0)-sizeof(element_1)-
      sizeof(element_2)-sizeof(element_3)-4-sizeof(sub0)];
  }
  else {
    u8 chunk_data[chunk_size-8-sizeof(element_0)-sizeof(element_1)-sizeof(element_2)-sizeof(element_3)];
  }
};

struct SomeData8 {
  u32 size;
  u8 unknown1[size];
  u8 unknown0[128];
};


struct Chunk8 {
  u32 chunk_id;
  u32 chunk_size;
  u32 magic_num;
  u32 magic_num1;
  u8 tag;
  u32 some_size;
  u32 terrain_x_dims; // Not sure what dims refer to. Maybe the terrain is divided into grid tiles?
  u32 terrain_y_dims;
  float some_float;
  float some_small_float; // checked that it is less than 1.570796 and >=0
  u16 some_size1;
  float some_float1;
  float some_float2;
  u8 tag1;
  u32 terrain_height_size_bytes;
  float terrain_heightmap[terrain_x_dims*terrain_y_dims]; // same as [terrain_height_size_bytes/4]
  u8 tag2;
  u32 num_terrain_tiles; // num terrain height vertices
  u8 terrain_texture_indices_maybe[num_terrain_tiles];
  u8 tag3;
  u32 some_size2;
  u8 some_size3;
  u8 some_data3[some_size3];
  u8 tag4;
  u32 some_size4;
  u8 some_size4_1;
  u8 some_data4[some_size4_1];
  u8 tag5;
  u32 some_size5;
  u8 some_data5[some_size5];
  u8 tag6;
  u32 num_terrain_tiles1;
  u8 terrain_shadow_map[num_terrain_tiles1];
  u8 tag7;
  u32 some_size7;
  SomeData8 some_per_32x32_tiles_data[terrain_x_dims*terrain_y_dims / 32 / 32];
  u32 unknown1;
  u8 zero;
  u8 chunk_data[chunk_size-76-sizeof(terrain_heightmap)
    -sizeof(terrain_texture_indices_maybe)-sizeof(some_data3)-sizeof(some_data4)
    -sizeof(some_data5)-sizeof(terrain_shadow_map)
    -sizeof(some_per_32x32_tiles_data)-5];
};

struct FileNameWith2Zeros{
  FileName file_name;
  u16 zero;
};

struct EnvironmentInfoFilenamesChunk {
  u32 chunk_id;
  u32 chunk_size;
  u16 unknown0;
  u16 unknown1;
  u8 unknown2;
  FileNameWith2Zeros filenames[(chunk_size - 5)  / sizeof(FileNameWith2Zeros)];
};

struct ShoreSubChunk {
  float float0;
  float shore_land_vertex_height; // The height of the vertex furthest from water
  float max_alpha; // values between 0 and 1. 0 means no shore and 1 means very visible shore waves. Anything higher than 1 and the game freezes.
  float wave_speed; // 0 is stopped and 1 is very fast. Less than 0 and the shore doesn't render. It can exceed 1 and get even faster.
  u32 vertices_count;
  Vertex2 vertices[vertices_count];
  u32 integer0;
};

struct ShoreChunk {
  u32 chunk_id;
  u32 chunk_size;
  char name[4];
  u32 unknown1;
  u32 subchunk_count;
  ShoreSubChunk subchunks[subchunk_count];
  
 u8 rem_data[chunk_size - 12 - 5 - sizeof(subchunks)];
  
 u32 unknown9;
 u8 zero;
};

// ============================================================================
// PATHFINDING / NAVMESH DATA (Chunk 0x20000008)
// ============================================================================
// Reference: gw1-map-viewer/src/loaders/pathfindingLoader.ts
// Verified via Ghidra analysis of Gw.exe (PathDataImport.cpp functions)
//
// This chunk contains the navigation mesh used for pathfinding.
// Structure: Trapezoids organized into planes (elevation levels).
// - Ground plane has index 0xFFFFFFFF
// - Elevated planes (bridges, platforms) are 0-indexed
//
// Tag order per plane (verified from function pointer table at 0xbadfe4):
// 0 -> 11 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 10 -> 9
// ============================================================================

// A single navigation mesh trapezoid (44 bytes)
// Trapezoids are convex quadrilaterals representing walkable areas.
// Coordinates are in world space:
// - yt, yb: Top and bottom Y coordinates (maps to world Z - forward/back)
// - xtl, xtr: Top-left and top-right X coordinates
// - xbl, xbr: Bottom-left and bottom-right X coordinates
//
// Verified from Path_import_trapezoids @ 0x006fa750:
// - Reads 0xB (11) uint32s = 44 bytes per trapezoid
// - Converts neighbor indices to pointers using (index * 0x30 + base)
struct PathfindingTrapezoid {
  // Neighbor trapezoid indices (PLANE-LOCAL, not global!)
  // 0xFFFFFFFF means no neighbor on that edge
  u32 neighbor_top_left;     // Trapezoid adjacent at top-left
  u32 neighbor_top_right;    // Trapezoid adjacent at top-right
  u32 neighbor_bottom_left;  // Trapezoid adjacent at bottom-left
  u32 neighbor_bottom_right; // Trapezoid adjacent at bottom-right

  // Portal indices (PLANE-LOCAL)
  // These reference the plane's portal array (Tag 9)
  // 0xFFFF means no portal on that edge
  u16 portal_left;   // Portal on left edge (for inter-plane transitions)
  u16 portal_right;  // Portal on right edge

  // World-space coordinates defining the trapezoid shape
  float yt;   // Top Y (world Z coordinate for top edge)
  float yb;   // Bottom Y (world Z coordinate for bottom edge)
  float xtl;  // Top-left X coordinate
  float xtr;  // Top-right X coordinate
  float xbl;  // Bottom-left X coordinate
  float xbr;  // Bottom-right X coordinate
};

// A portal connects trapezoids on different planes (9 bytes)
// E.g., connecting ground level to a bridge
//
// Verified from PathData_ImportPortals @ 0x006fa1b0:
// - Reads 9 bytes per portal
struct PathfindingPortal {
  u16 traps_count;        // Number of trapezoids accessible via this portal
  u16 traps_idx;          // Index into portal_traps array (Tag 10)
  u16 neighbor_plane_id;  // Plane this portal connects to
  u16 neighbor_shared_id; // Used to pair portals across planes (same ID = paired)
  u8 flags;               // Bit 0x4 = not used for pathfinding
};

// X-axis BSP node (16 bytes)
// Used for spatial subdivision to speed up point-in-trapezoid queries
// Verified from Path_import_x_nodes @ 0x006fa470: reads 4 uint32s per node
struct PathfindingXNode {
  u32 vertex_index_start;  // Start vertex index
  u32 vertex_index_end;    // End vertex index
  u32 left_child_index;    // Left child node (or trapezoid) index
  u32 right_child_index;   // Right child node (or trapezoid) index
};

// Y-axis BSP node (12 bytes)
// Verified from Path_import_y_nodes @ 0x006fa5c0: reads 3 uint32s per node
struct PathfindingYNode {
  u32 vertex_index;        // Vertex index for split position
  u32 left_child_index;    // Left child node index
  u32 right_child_index;   // Right child node index
};

// Sink node (4 bytes) - references a trapezoid
// Verified from Path_import_sink_nodes @ 0x006fa3f0: reads 1 uint32 per node
struct PathfindingSinkNode {
  u32 trapezoid_index;     // Index into plane's trapezoid array
};

// Plane header counts (Tag 0, 32 bytes of data after tag+size)
// Verified from PathChunk_AllocArrays @ 0x006f9aa0: reads 8 uint32s
struct PathfindingPlaneHeader {
  u32 h000C;              // Used for Tag 11 poly data size (h000C * 8 bytes)
  u32 vectors_count;      // Number of 2D edge vectors (8 bytes each)
  u32 trapezoids_count;   // Number of trapezoids in this plane (44 bytes each)
  u32 xnodes_count;       // X-axis BSP nodes (16 bytes each)
  u32 ynodes_count;       // Y-axis BSP nodes (12 bytes each)
  u32 sinknodes_count;    // Sink nodes (4 bytes each)
  u32 portals_count;      // Number of portals (9 bytes each)
  u32 portal_traps_count; // Number of portal-trapezoid indices (4 bytes each)
};

// Tag wrapper for reading tagged data sections
struct PathfindingTag {
  u8 tag;
  u32 size;
};

// Static obstacle (tree, rock, pillar, etc.)
// Circular collision primitive blocking character movement
// From Ghidra analysis of PathObstacle_Import @ 0x006f8e20
struct StaticObstacle {
    float x;       // World X coordinate
    float y;       // World Y coordinate (Z in 3D)
    float radius;  // Collision radius
};

// Obstacle grid cell for spatial partitioning
// Each cell contains an index into the obstacle array
struct ObstacleGridCell {
    u8 obstacleIndex;   // Index into obstacle array (0xFF = empty)
    u8 nextCell;        // Chain to next cell with obstacle
    u8 flags;           // Cell flags
};

// Tag 13 obstacle data with grid-based spatial partitioning
struct PathfindingObstacleData {
    u16 gridWidth;
    u16 gridHeight;
    u16 obstacleCount;

    // Spatial partitioning grid for fast obstacle lookups
    ObstacleGridCell cells[gridWidth * gridHeight];

    // Actual obstacle collision data
    StaticObstacle obstacles[obstacleCount];
};

// A complete pathfinding plane (one elevation level)
// Tag order verified from function pointer table at 0xbadfe4-0xbae00c
//
// IMPORTANT: The game reads h000C * 8 bytes from tag 11 but the file contains
// the full tag size. For accurate parsing, we use the tag size from the file.
struct PathfindingPlane {
  // Tag 0: Header with counts (PathChunk_AllocArrays)
  PathfindingTag header_tag;  // tag=0, size=32
  PathfindingPlaneHeader header;

  // Tag 11 (0xB): Poly boundary data (PathChunk_ReadPolyData @ 0x006f9a40)
  // NOTE: File tag size may be h000C * 16, but game only reads h000C * 8 bytes.
  // The next tag starts after h000C * 8 bytes, NOT after the declared tag size!
  // This is a quirk in the file format - tag size is misleading for tag 11.
  PathfindingTag poly_data_tag;  // tag=11 (ignore size, use h000C * 8)
  Vertex2 poly_data[header.h000C];  // h000C * 8 bytes

  // Tag 1: Edge vectors (PathData_ImportEdges @ 0x006fa950)
  // 2D vectors for edge directions, vectors_count * 8 bytes
  PathfindingTag vectors_tag;  // tag=1
  Vertex2 vectors[header.vectors_count];

  // Tag 2: Trapezoids (Path_import_trapezoids @ 0x006fa750)
  // The core navmesh geometry, 44 bytes per trapezoid
  PathfindingTag trapezoids_tag;  // tag=2
  PathfindingTrapezoid trapezoids[header.trapezoids_count];

  // Tag 3: Root node type (Path_set_root_node_type @ 0x006fa6c0)
  // Single byte: 0=X_NODE, 1=Y_NODE, 2=SINK_NODE
  PathfindingTag root_node_tag;  // tag=3, size=1
  u8 root_node_type;

  // Tag 4: X-axis BSP nodes (Path_import_x_nodes @ 0x006fa470)
  // 16 bytes per node for spatial partitioning
  PathfindingTag xnodes_tag;  // tag=4
  PathfindingXNode xnodes[header.xnodes_count];

  // Tag 5: Y-axis BSP nodes (Path_import_y_nodes @ 0x006fa5c0)
  // 12 bytes per node
  PathfindingTag ynodes_tag;  // tag=5
  PathfindingYNode ynodes[header.ynodes_count];

  // Tag 6: Sink nodes (Path_import_sink_nodes @ 0x006fa3f0)
  // 4 bytes per node (trapezoid index)
  PathfindingTag sinknodes_tag;  // tag=6
  PathfindingSinkNode sinknodes[header.sinknodes_count];

  // Tag 10 (0xA): Portal trapezoid indices (PathData_ImportStateRefs @ 0x006fa130)
  // Indices into this plane's trapezoid array, referenced by portals
  PathfindingTag portal_traps_tag;  // tag=10
  u32 portal_trapezoid_indices[header.portal_traps_count];

  // Tag 9: Portal definitions (PathData_ImportPortals @ 0x006fa1b0)
  // 9 bytes per portal, enables transitions between planes
  PathfindingTag portals_tag;  // tag=9
  PathfindingPortal portals[header.portals_count];
};

// Main pathfinding chunk (chunk_id 0x20000008)
// Verified from PathChunk_ReadHeader @ 0x006f9040:
// - Signature check: 0xEEFE704C
// - Version check: byte at offset 4 == 0x0C (only low byte checked)
// - Total header: 12 bytes (4 + 4 + 4), aligned to 4 bytes
//
// Structure after planes: Tags 12, 13, 14 (node properties, obstacle, state data)
// followed by 0xFF terminator
struct PathfindingChunk {
  u32 chunk_id;
  u32 chunk_size;

  // Header (12 bytes total)
  u32 signature;  // 0xEEFE704C (little-endian)
  u32 version;    // Low byte is 0x0C, upper 3 bytes are padding/unused
  u32 sequence;   // Sequence number

  // Tag 7: Preamble/validation data (optional, precedes tag 8)
  // Contains checksums or other validation data
  PathfindingTag preamble_tag;  // tag=7
  u8 preamble_data[preamble_tag.size];

  // Tag 8: Contains all plane data (PathData_ImportStates @ 0x006f9dd0)
  PathfindingTag planes_tag;  // tag=8
  u32 plane_count;
  PathfindingPlane planes[plane_count];

  // Tag 12 (0x0C): Node properties (PathData_ImportNodeProperties)
  PathfindingTag node_props_tag;  // tag=12
  u8 node_props_data[node_props_tag.size];

  // Tag 13 (0x0D): Obstacle data (PathData_ImportObstacle)
  // Grid-based spatial partitioning for collision detection
  PathfindingTag obstacle_tag;  // tag=13
  PathfindingObstacleData obstacles;

  // Tag 14 (0x0E): State data
  PathfindingTag state_tag;  // tag=14
  u8 state_data[state_tag.size];

  // Terminator (PathChunk_ReadTerminator @ 0x006f8ab0)
  PathfindingTag terminator_tag;  // tag=0xFF, size=0
};

struct EnvSubChunk0 {
   u8 unknown0;
   u8 unknown1;
   s32 unknown2;
   u8 unknown3;
   u8 unknown4;
   u16 unknown5;
};

struct EnvSubChunk1 {
   u8 sky_brightness_maybe; // at 0 the sky is less bright and no specular highlights
   u8 sky_saturaion_maybe; // not sure if saturation but changes colors.
   u8 some_color_scale; // 0xff more gray-scale, 0 normal color.
   u16 unknown2;
   u8 unknown4;
};

struct EnvSubChunk2 {
   u8 fog_blue;
   u8 fog_green;
   u8 fog_red;
   u32 fog_distance_start;
   u32 fog_distance_end;
   s32 fog_z_start_maybe;
   s32 fog_z_end_maybe; // remember GW uses negative height
};

// Setting this whole chunk to 0 turns everything black except specular highlights it seems.
// and some exceptions to the above.
struct EnvSubChunk3 {
   // Ambient light perhaps.
   u8 ambient_blue;
   u8 ambient_green;
   u8 ambient_red;
   u8 ambient_intensity; // setting to zero makes all shadows completely black.

   // These select the color of everywhere directly hit by the sun light
   // No effect on the places in shadow.
   u8 sun_blue;
   u8 sun_green;
   u8 sun_red;
   u8 sun_intensity;
};

struct EnvSubChunk4 {
   u8 data[2];
};

struct EnvSubChunk5 {
   u8 cloud_cylinder_radius_scale_maybe; // Always at 0xff? Settings it to lower values than 0xff seem to create a second cylinder for the clouds that is smaller than be sky cylinder.
   
   // Settings these indices to 0xFFFF makes the game not load it.
   u16 sky_background_texture_index;
   u16 sky_clouds_texture_index0;
   u16 sky_clouds_texture_index1;
   u16 sky_sun_texture_index;
   
   u8 unknown0; // the higher the number the higher up the fog seem to cover the sky
   
   // Probably sky cylinder dimensions (height and radius)
   s16 unknown1;
   s16 unknown2;
   u8 unknown3;
   //u8 data[0xf-9];
};

// This is used if the value 4 bytes after magic_num_0x92991030 is >= 0x00010000
struct EnvSubChunk5_other {
   u8 cloud_cylinder_radius_scale_maybe;
   u16 sky_background_texture_index;
   u16 sky_clouds_texture_index0;
   u16 sky_clouds_texture_index1;
   u16 sky_sun_texture_index;
   u8 unknown[7];
};

// Water environment info most likely
struct EnvSubChunk6 {
   u8 unknown[9];
   float unknown1;
   float water_distortion_tex_scale; // small means larger scale and big means smaller scale.
   float water_distortion_scale; // small and the water surface is completely flat with good reflections. High and all reflections disappear. Crashes Gw with too high values. 10 didnt crash lakeside 100 did. 
   float water_distortion_tex_speed;
   float water_color_tex_scale;
   float water_color_tex_speed;
   float water_color_and_alpha_related; // 0 means water is less transparent and more of the water color texture is applied. Higher numbers does the opposite: makes it more transparent.
   float water0;
   float water1;
   // The colors have a strong effect on the final color of the water. 
   // the 1 colors seem to be stronger than the 0 colors. If alpha is set 
   // to 255 for both then the 1 colors might overwrite the 0 colors.
   // If alpha is set to 0 then the water is fully transparent.
   u8 blue_color0;
   u8 green_color0;
   u8 red_color0;
   u8 alpha0;
   u8 blue_color1;
   u8 green_color1;
   u8 red_color1;
   u8 alpha1;
   u16 water_color_texture_index;
   u16 water_distortion_texture_index;
};

struct EnvSubChunk7 {
   u8 wind_dir0;
   u8 wind_dir1;
   u8 wind_speed0;
   u8 wind_speed1;
};

struct EnvSubChunk8 {
   u8 unknown1[0x9];
   float unknown2;
   float unknown3;
   u8 data[15];
};

struct EnvironmentInfoChunk {
 u32 chunk_id;
 u32 chunk_size;
 u32 magic_num_0x92991030;
 u16 always_0x10_maybe;
 u16 unknown;
 u8 data_type; // if 0 or 2 then the next bytes are u8 tag and u32 size I think.
 u16 num_structs0;
 EnvSubChunk0 env_sub_chunk0[num_structs0];
 u8 data_type1;
 u16 num_structs1;
 EnvSubChunk1 env_sub_chunk1[num_structs1];
 u8 data_type2;
 u16 num_structs2;
 EnvSubChunk2 env_sub_chunk2[num_structs2];
 u8 data_type3;
 u16 num_structs3;
 EnvSubChunk3 env_sub_chunk3[num_structs3];
 u8 data_type4;
 u16 num_structs4;
 EnvSubChunk4 env_sub_chunk4[num_structs4];
 u8 data_type5;
 // Texture file indices (see chunk 0x21000009 for the environment files)
 // and other things.
 u16 num_structs5;
 if (unknown > 0) {
   EnvSubChunk5_other env_sub_chunk5[num_structs5];
 }
 else{
   EnvSubChunk5 env_sub_chunk5[num_structs5];
 }
 u8 data_type6;
 u16 num_structs6;
 EnvSubChunk6 env_sub_chunk6[num_structs6];
 u8 data_type7;
 u16 num_structs7;
 EnvSubChunk7 env_sub_chunk7[num_structs7];
 u8 unknown0;
 u16 unknown1[8];
 u8 unknown2;
 u8 data_type8;
 u8 num_structs8;
 EnvSubChunk8 enb_sub_chunk8[num_structs8];
 u16 unknown_3; // always 0x00 0x0B?
 u16 num_structs9;
 u8 structs9[5*num_structs9];
 // Some files have extra bytes before the end marker - read remaining data dynamically
 u8 trailing_data[chunk_size - ($ - addressof(magic_num_0x92991030))];
};

enum FFNAType : u8 {
  Type0,
  Type1,
  Model,
  Map,
  Type4,
  Type5,
  Type6,
  Type7
};

// ============================================================================
// 0x10 FORMAT STUB CHUNKS
// ============================================================================
// The 0x10 format files are lightweight reference/metadata files with minimal
// actual data. They use chunk IDs 0x10xxxxxx instead of 0x20xxxxxx.
// These chunks have the same basic structure but contain stub/minimal data.

// 0x10000000 - Generic header stub
struct Chunk1_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x1000000C - Map params stub (same structure as 0x20)
struct Chunk2_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u32 magic_num;
  u8 always_2;
  MapBounds map_bounds;
  u32 f0;
  u32 f1;
  u32 f2;
  u32 f3;
  u32 f4;
};

// 0x10000003 - Zones stub
struct Chunk5_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000004 - Props info stub
struct Chunk3_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000002 - Terrain stub (smaller grid)
struct Chunk8_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x11000002, 0x11000003, 0x11000004, etc. - Filename chunks stub
struct Chunk4_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000008 - Pathfinding stub (minimal boundary data only)
// Contains signature + boundary floats + terminator, no actual navmesh
struct PathfindingChunk_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u32 signature;  // 0xEEFE704C
  u8 stub_data[chunk_size - 4];  // Minimal data including 0xFF terminator
};

// 0x10000009 - Environment info stub
struct EnvironmentInfoChunk_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000010 - Shore stub
struct ShoreChunk_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x1000000E - Unknown stub
struct Chunk0E_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000013 - Unknown stub
struct Chunk13_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000007 - Unknown stub
struct Chunk07_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000006 - Unknown stub
struct Chunk06_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x1000000A - Unknown stub
struct Chunk0A_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x1000000F - Unknown stub
struct Chunk0F_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000011 - Unknown stub
struct Chunk11_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000012 - Unknown stub
struct Chunk12_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// 0x10000014 - Unknown stub
struct Chunk14_Stub {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

struct UnknownChunk {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

struct Chunk {
 u32 chunk_id = std::mem::read_unsigned($, 4);

 // ========== 0x20 FORMAT (Full data) ==========
 if (chunk_id == 0x20000000){
   Chunk1 chunk1;
 }
 else if (chunk_id == 0x20000002){
   Chunk8 terrain_chunk;
 }
 else if (chunk_id == 0x20000003){
   Chunk5_0 chunk5;
 }
 else if (chunk_id == 0x20000004){
   Chunk3 chunk3;
 }
 else if (chunk_id == 0x2000000C){
   Chunk2 chunk2;
 }
 else if (chunk_id == 0x21000002){
   Chunk4 terrain_texture_filenames;
 }
 else if (chunk_id == 0x21000003){
   Chunk4 more_filenames_chunk;
 }
 else if (chunk_id == 0x21000004){
   Chunk4 filenames_chunk;
 }
 else if (chunk_id == 0x21000009){
   EnvironmentInfoFilenamesChunk environment_info_filenames_chunk;
 }
 else if (chunk_id == 0x20000010){
   ShoreChunk shore_chunk;
 }
 else if (chunk_id == 0x21000010){
   Chunk4 shore_filenames;
 }
 else if (chunk_id == 0x20000008){
   PathfindingChunk pathfinding_chunk;
 }
 else if (chunk_id == 0x20000009){
   EnvironmentInfoChunk environment_info_chunk;
 }
 else if (chunk_id == 0x21000012){
   Chunk4 map_audio_related_filenames;
 }
 else if (chunk_id == 0x21000006){
   Chunk4 unknown_chunk;
 }

 // ========== 0x10 FORMAT (Stub/lightweight data) ==========
 else if (chunk_id == 0x10000000){
   Chunk1_Stub chunk1_stub;
 }
 else if (chunk_id == 0x10000002){
   Chunk8_Stub terrain_chunk_stub;
 }
 else if (chunk_id == 0x10000003){
   Chunk5_Stub chunk5_stub;
 }
 else if (chunk_id == 0x10000004){
   Chunk3_Stub chunk3_stub;
 }
 else if (chunk_id == 0x1000000C){
   Chunk2_Stub chunk2_stub;
 }
 else if (chunk_id == 0x11000002){
   Chunk4_Stub terrain_texture_filenames_stub;
 }
 else if (chunk_id == 0x11000003){
   Chunk4_Stub more_filenames_chunk_stub;
 }
 else if (chunk_id == 0x11000004){
   Chunk4_Stub filenames_chunk_stub;
 }
 else if (chunk_id == 0x11000009){
   Chunk4_Stub environment_info_filenames_stub;
 }
 else if (chunk_id == 0x10000010){
   ShoreChunk_Stub shore_chunk_stub;
 }
 else if (chunk_id == 0x11000010){
   Chunk4_Stub shore_filenames_stub;
 }
 else if (chunk_id == 0x10000008){
   PathfindingChunk_Stub pathfinding_chunk_stub;
 }
 else if (chunk_id == 0x10000009){
   EnvironmentInfoChunk_Stub environment_info_chunk_stub;
 }
 else if (chunk_id == 0x11000012){
   Chunk4_Stub map_audio_filenames_stub;
 }
 else if (chunk_id == 0x11000006){
   Chunk4_Stub unknown_chunk_stub;
 }
 else if (chunk_id == 0x1000000E){
   Chunk0E_Stub chunk0e_stub;
 }
 else if (chunk_id == 0x10000013){
   Chunk13_Stub chunk13_stub;
 }
 else if (chunk_id == 0x10000007){
   Chunk07_Stub chunk07_stub;
 }
 else if (chunk_id == 0x10000006){
   Chunk06_Stub chunk06_stub;
 }
 else if (chunk_id == 0x1000000A){
   Chunk0A_Stub chunk0a_stub;
 }
 else if (chunk_id == 0x1000000F){
   Chunk0F_Stub chunk0f_stub;
 }
 else if (chunk_id == 0x10000011){
   Chunk11_Stub chunk11_stub;
 }
 else if (chunk_id == 0x10000012){
   Chunk12_Stub chunk12_stub;
 }
 else if (chunk_id == 0x10000014){
   Chunk14_Stub chunk14_stub;
 }

 // ========== Unknown chunks ==========
 else{
   UnknownChunk unknown_chunk;
 }
};


struct MapFile {
 char ffna_signature[4];
 FFNAType ffna_type;
 Chunk chunks[while($ < sizeof($))];
 };
 
MapFile mapfile @ 0;