#include <std/mem.pat>
#include <std/math.pat>
#include <std/io.pat>
#pragma pattern_limit 500000

// =============================================================================
// FFNA Type 2 "Other" Model File Pattern
// These model files use chunk IDs in the 0xBB* range instead of 0xFA* range
// They also contain inline ATEX textures instead of file references
//
// Based on reverse engineering of the game's MdlDecomp.cpp functions:
// - MdlDecomp_ConvertGeometryChunk_0xBB8_to_0xFA0 (0x0076d380)
// - MdlDecomp_ConvertSubmesh (0x0076dbe0)
// - MdlDecomp_ConvertAllChunks (0x00771090)
// =============================================================================

// Chunk ID mappings (Other -> Standard):
// 0xBB8 (3000) -> 0xFA0 (4000): Geometry (different internal format!)
// 0xBB9 (3001) -> 0xFA1 (4001): Animation/Skeleton
// 0xBBA (3002) -> 0xFA4 (4004): Metadata (version info)
// 0xBBB (3003) -> 0xFA5 (4005): Texture filenames
// 0xBBC (3004) -> 0xFA6 (4006): Additional filenames
// 0xBBE (3006) -> 0xFA9 (4009): Version/header data
// 0xBBF (3007) -> 0xFAB (4011): Index buffer data
// 0xBC0 (3008) -> 0xFAD (4013): Additional data
// 0xBC1 (3009) -> 0xFAE (4014): Additional data
// 0xFA3 (4003): Inline ATEX DXT3 texture
// 0xFAA (4010): Inline ATEX DXTA texture

// ClassFlags bitmask for 0xBB8 geometry header (offset 0x08):
//   0x002: Bone group data (max 4 groups, 28 bytes each)
//   0x004: Bounding box data
//   0x008: Submesh data
//   0x010: LOD data
//   0x020: Vertex buffer data
//   0x040: Bone weights
//   0x080: Morph target data
//   0x100: Animation data
//   0x200: Skeleton data (max 32 bones, 255 weights)
//   0x400: Extended LOD data

// UV coordinates use a delta+offset compression format:
// - After positions, there's num_vertices * 4 bytes of per-vertex data (colors/weights)
// - UV Header: count0 (uint16), count1 (uint16)
// - Offset arrays: u_thresholds[count0], v_thresholds[count1], u_offsets[count0], v_offsets[count1]
// - Delta data: (u_delta, v_delta) uint16 pairs per vertex
// - Final UV = delta * (1/65536) + offset
// Scale factor: 1.0/65536.0 = 0x37800000 as float

fn compute_str_len_plus_one(u32 address){
  u32 counter = 0;
  bool found = false;
  while (!found && counter < 256){
    u8 curr_char @ address + counter;
    if (curr_char == 0){
      found = true;
    }
    counter += 1;
  }
  return counter;
};

struct String {
  char string[compute_str_len_plus_one($)];
};

// =============================================================================
// ATEX inline texture format
// =============================================================================
struct ATEXHeader {
  char signature[4];      // "ATEX"
  char format[4];         // "DXT3", "DXTA", "DXT1", "DXT5", etc.
  u16 width;
  u16 height;
  u32 data_size;
  u32 mip_levels;         // Number of mip levels or flags
};

struct ATEXChunk {
  u32 chunk_id;
  u32 chunk_size;
  ATEXHeader header [[name("ATEX Header")]];
  u8 texture_data[chunk_size - sizeof(ATEXHeader)] [[name("Texture Data")]];
};

// =============================================================================
// Chunk 0xBB8 (3000) - Geometry chunk (compressed format)
// The game's MdlDecomp_ConvertGeometryChunk_0xBB8_to_0xFA0 converts this
// to standard 0xFA0 format at runtime
//
// IMPORTANT: Header is 0x30 (48) bytes, NOT 0x40 (64) bytes!
// Verified from disassembly at 0x0076d3bd: LEA EAX, [ESI + 0x30]
// =============================================================================
struct ChunkBB8_Header {
  u32 field_0x00;                 // 0x00: Type/version flags
  u32 field_0x04;                 // 0x04: Usually 0
  u32 class_flags;                // 0x08: Bitmask controlling data sections
  u32 signature0;                 // 0x0C: Model signature part 1
  u32 signature1;                 // 0x10: Model signature part 2
  u32 field_0x14;                 // 0x14
  u8  num_bone_groups;            // 0x18: Number of bone groups (max 4)
  u8  num_texture_groups;         // 0x19: Number of texture groups
  u16 num_textures;               // 0x1A: Number of textures
  u8  num_bone_weights;           // 0x1C: Number of bone weights
  u8  num_bone_indices;           // 0x1D: Number of bone indices
  u16 num_materials;              // 0x1E: Number of materials
  u32 num_bone_weight_sets;       // 0x20: Number of bone weight sets
  u32 class_flags_output;         // 0x24: Output class flags (stored in output)
  float scale_x;                  // 0x28: X scale factor for submeshes
  float scale_y;                  // 0x2C: Y scale factor for submeshes
  // Total: 0x30 (48) bytes - NOT 64!
};

// Submesh header within the geometry data (24 bytes = 6 DWORDs)
// Discovered through binary analysis of actual model files.
// The header starts at a variable offset after the 48-byte geometry header.
// Data after this header:
//   - Index buffer: num_indices * 2 bytes (uint16 indices)
//   - Position buffer: num_vertices * 12 bytes (float triplets)
struct SubmeshBB8_Header {
  u32 num_indices;                // 0x00: Number of indices (16-bit)
  u32 num_vertices;               // 0x04: Number of vertices
  u32 num_uv_sets;                // 0x08: Number of UV coordinate sets per vertex
  u32 num_vertex_groups;          // 0x0C: Number of vertex groups/bone groups
  u32 num_colors;                 // 0x10: Number of color values
  u32 num_normals;                // 0x14: Number of normals/additional data
  // Total: 0x18 (24) bytes
};

// Vertex position (3 floats = 12 bytes)
struct VertexPosition {
  float x;
  float y;
  float z;
};

// Global variables for submesh parsing
u32 g_submesh_offset;
u32 g_num_indices;
u32 g_num_vertices;
u32 g_geom_data_size;

// Scan for submesh header pattern at 2-byte boundaries
// Sets global variables and returns true if found
fn find_submesh_header(u32 data_start, u32 data_size) {
  u32 offset = 0;
  while (offset < std::math::min(data_size, 300)) {
    if (offset + 48 > data_size) break;

    u32 num_indices = std::mem::read_unsigned(data_start + offset, 4);
    u32 num_vertices = std::mem::read_unsigned(data_start + offset + 4, 4);

    // Validate counts
    if (num_indices >= 6 && num_indices <= 100000 &&
        num_vertices >= 3 && num_vertices <= 50000 &&
        num_indices >= num_vertices) {

      // Check if data would fit
      u32 idx_start = offset + 24;
      u32 idx_size = num_indices * 2;
      u32 pos_start = idx_start + idx_size;
      u32 pos_size = num_vertices * 12;

      if (pos_start + pos_size <= data_size) {
        // Validate first few indices are < num_vertices
        u16 idx0 = std::mem::read_unsigned(data_start + idx_start, 2);
        u16 idx1 = std::mem::read_unsigned(data_start + idx_start + 2, 2);
        u16 idx2 = std::mem::read_unsigned(data_start + idx_start + 4, 2);
        if (idx0 < num_vertices && idx1 < num_vertices && idx2 < num_vertices) {
          // Found it!
          g_submesh_offset = offset;
          g_num_indices = num_indices;
          g_num_vertices = num_vertices;
          return true;
        }
      }
    }
    offset = offset + 2;
  }
  g_submesh_offset = 0;
  g_num_indices = 0;
  g_num_vertices = 0;
  return false;
};

// Per-vertex extra data (colors/weights) - 4 bytes per vertex
struct VertexExtraData {
  u8 data[4];  // RGBA color or bone weights
};

// UV delta pair (uint16, scaled by 1/65536)
struct UV_Delta {
  u16 u_delta;
  u16 v_delta;
};

// UV header and offset arrays
// Layout: count0, count1, u_thresholds[count0], v_thresholds[count1], u_offsets[count0], v_offsets[count1]
struct UVHeader {
  u16 count0;         // Number of U offset entries
  u16 count1;         // Number of V offset entries
  // Followed by: u_thresholds[count0] (uint16 each) - vertex index thresholds
  // Followed by: v_thresholds[count1] (uint16 each)
  // Followed by: u_offsets[count0] (int16 each) - offset values to add
  // Followed by: v_offsets[count1] (int16 each)
};

// Full submesh with indices, positions, extra data, and UVs
struct SubmeshBB8_Full {
  SubmeshBB8_Header header [[name("Submesh Header")]];
  u16 indices[header.num_indices] [[name("Index Buffer")]];
  VertexPosition positions[header.num_vertices] [[name("Vertex Positions")]];
  // Per-vertex extra data (colors/weights) comes after positions
  VertexExtraData extra_data[header.num_vertices] [[name("Per-Vertex Extra Data (colors/weights)")]];
  // UV header with offset arrays
  UVHeader uv_header [[name("UV Header")]];
  // Offset arrays (simplified - actual size depends on count0/count1)
  u16 uv_offset_arrays[(uv_header.count0 + uv_header.count1) * 2] [[name("UV Offset Arrays")]];
  // UV delta data (uint16 pairs, final UV = delta/65536 + offset)
  UV_Delta uv_deltas[header.num_vertices * header.num_uv_sets] [[name("UV Delta Data (uint16/65536)")]];
};

// Geometry data with parsed submesh
struct GeometryDataParsed {
  u32 data_start = $;

  // Find submesh header - sets globals
  bool found = find_submesh_header(data_start, g_geom_data_size);

  // Pre-submesh data (texture groups, materials, bone data, etc.)
  if (g_submesh_offset > 0) {
    u8 pre_submesh_data[g_submesh_offset] [[name("Pre-Submesh Data (texture groups, materials, etc.)")]];
  }

  // Parse the actual submesh if found
  if (found) {
    SubmeshBB8_Full submesh [[name("Submesh")]];

    // Data layout after submesh header:
    //   - Indices: num_indices * 2 bytes
    //   - Positions: num_vertices * 12 bytes
    //   - Extra data (colors/weights): num_vertices * 4 bytes
    //   - UV header: 4 bytes (count0, count1)
    //   - UV offset arrays: (count0 + count1) * 4 bytes
    //   - UV deltas: num_vertices * num_uv_sets * 4 bytes
    u32 consumed = g_submesh_offset + 24 + g_num_indices * 2 + g_num_vertices * 12;
    // Add extra data size (colors/weights)
    consumed = consumed + g_num_vertices * 4;
    // Add UV header and offset arrays (read count0, count1 to calculate)
    u16 uv_count0 = std::mem::read_unsigned(data_start + consumed, 2);
    u16 uv_count1 = std::mem::read_unsigned(data_start + consumed + 2, 2);
    consumed = consumed + 4 + (uv_count0 + uv_count1) * 4;
    // Add UV delta data
    u32 num_uv_sets = std::mem::read_unsigned(data_start + g_submesh_offset + 8, 4);
    if (num_uv_sets > 8) num_uv_sets = 1;
    consumed = consumed + g_num_vertices * num_uv_sets * 4;

    // Footer/remaining data
    if (consumed < g_geom_data_size) {
      u8 remaining_data[g_geom_data_size - consumed] [[name("Remaining Data")]];
    }
  } else {
    // Fallback: just show raw data
    u8 raw_geometry_data[g_geom_data_size] [[name("Raw Geometry Data (submesh not found)")]];
  }
};

struct ChunkBB8_Geometry {
  u32 chunk_id;
  u32 chunk_size;
  ChunkBB8_Header header [[name("Geometry Header")]];

  // Set global for data size before parsing
  g_geom_data_size = chunk_size - sizeof(ChunkBB8_Header);

  // Parse geometry data with submesh detection
  GeometryDataParsed geometry [[name("Geometry Data")]];
};

// =============================================================================
// Chunk 0xBB9 (3001) - Animation/Skeleton chunk
// Converted by MdlDecomp_ConvertGeometryChunk_0xBB9_to_0xFA1
// =============================================================================
struct ChunkBB9_Header {
  u32 type_marker;        // Usually 0x26
  u32 f0x4;
  u32 flags;              // 0x10 typically
  u32 signature0;
  u32 signature1;
};

struct ChunkBB9_Animation {
  u32 chunk_id;
  u32 chunk_size;
  ChunkBB9_Header header [[name("Animation Header")]];
  u8 animation_data[chunk_size - sizeof(ChunkBB9_Header)] [[name("Animation Data")]];
};

// =============================================================================
// Chunk 0xBBA (3002) - Version/Metadata chunk
// =============================================================================
struct ChunkBBA_Metadata {
  u32 chunk_id;
  u32 chunk_size;
  u32 version;            // Usually 2
  u8 data[chunk_size - 4] [[name("Metadata")]];
};

// =============================================================================
// Chunk 0xBBB (3003) - Texture filenames (like 0xFA5)
// Each entry is 6 bytes in "other" format:
//   id0 (uint16): Encoded filename part 1
//   id1 (uint16): Encoded filename part 2
//   unknown (uint16): Usually 0
// Decode: file_hash = (id0 - 0xFF00FF) + (id1 * 0xFF00)
// =============================================================================
struct TextureFileNameOther {
  u16 id0;          // Encoded filename part 1
  u16 id1;          // Encoded filename part 2
  u16 unknown;      // Usually 0
  // Decoded hash = (id0 - 0xFF00FF) + (id1 * 0xFF00)
};

struct ChunkBBB_TextureFilenames {
  u32 chunk_id;
  u32 chunk_size;
  u32 unknown;              // Unknown field (usually small value)
  u32 num_filenames_field;  // Actual count of texture filename entries

  TextureFileNameOther filenames[num_filenames_field];

  if (chunk_size > 8 + num_filenames_field * 6) {
    u8 remaining[chunk_size - 8 - num_filenames_field * 6];
  }
};

// =============================================================================
// Chunk 0xBC0 (3008) - Additional data chunk
// =============================================================================
struct ChunkBC0_AdditionalData {
  u32 chunk_id;
  u32 chunk_size;
  u32 version;            // Usually 1
  u32 count;
  u8 data[chunk_size - 8] [[name("Additional Data")]];
};

// =============================================================================
// Generic chunk for unknown types
// =============================================================================
struct UnknownChunk {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

// =============================================================================
// Chunk dispatcher
// =============================================================================
struct Chunk {
  u32 chunk_id = std::mem::read_unsigned($, 4);

  if (chunk_id == 0xBB8) {
    ChunkBB8_Geometry geometry_chunk [[name("Geometry (0xBB8)")]];
  }
  else if (chunk_id == 0xBB9) {
    ChunkBB9_Animation animation_chunk [[name("Animation (0xBB9)")]];
  }
  else if (chunk_id == 0xBBA) {
    ChunkBBA_Metadata metadata_chunk [[name("Metadata (0xBBA)")]];
  }
  else if (chunk_id == 0xBBB || chunk_id == 0xBBC) {
    ChunkBBB_TextureFilenames texnames_chunk [[name("Texture Filenames")]];
  }
  else if (chunk_id == 0xBC0 || chunk_id == 0xBC1) {
    ChunkBC0_AdditionalData additional_chunk [[name("Additional Data")]];
  }
  else if (chunk_id == 0xFA3 || chunk_id == 0xFAA) {
    ATEXChunk atex_chunk [[name("Inline ATEX Texture")]];
  }
  else {
    UnknownChunk unknown_chunk [[name("Unknown Chunk")]];
  }
};

// =============================================================================
// Main file structure
// =============================================================================
struct ModelFile {
  char ffna_signature[4] [[name("FFNA Signature")]];   // "ffna"
  u8 file_type [[name("File Type")]];                   // Should be 2 for model files
  Chunk chunks[while($ < sizeof($))] [[name("Chunks")]];
};

ModelFile modelfile @ 0;
