#include <std/mem.pat>
#include <std/math.pat>
#include <std/io.pat>
#pragma pattern_limit 500000
std::mem::Section provider = std::mem::create_section("Memory provider");
u32 fvf_array_0[22] @0x00 in provider;
u32 fvf_array_1[8] @0x00+sizeof(fvf_array_0) in provider;
u32 fvf_array_2[16] @0x00+sizeof(fvf_array_0)+sizeof(fvf_array_1) in provider;

fvf_array_0[0] = 0x0;
fvf_array_0[1] = 0x8;
fvf_array_0[2] = 0x8;
fvf_array_0[3] = 0x10;
fvf_array_0[4] = 0x8;
fvf_array_0[5] = 0x10;
fvf_array_0[6] = 0x10;
fvf_array_0[7] = 0x18;
fvf_array_0[8] = 0x8;
fvf_array_0[9] = 0x10;
fvf_array_0[10] = 0x10;
fvf_array_0[11] = 0x18;
fvf_array_0[12] = 0x10;
fvf_array_0[13] = 0x18;
fvf_array_0[14] = 0x18;
fvf_array_0[15] = 0x20;
fvf_array_0[16] = 0x0;
fvf_array_0[17] = 0x0;
fvf_array_0[18] = 0x0;
fvf_array_0[19] = 0x1;
fvf_array_0[20] = 0xFFFFFFFF;
fvf_array_0[21] = 0xFFFFFFFF;

fvf_array_1[0] = 0x0;
fvf_array_1[1] = 0xC;
fvf_array_1[2] = 0xC;
fvf_array_1[3] = 0x18;
fvf_array_1[4] = 0xC;
fvf_array_1[5] = 0x18;
fvf_array_1[6] = 0x18;
fvf_array_1[7] = 0x24;

fvf_array_2[0] = 0x0;
fvf_array_2[1] = 0xC;
fvf_array_2[2] = 0x4;
fvf_array_2[3] = 0x10;
fvf_array_2[4] = 0xC;
fvf_array_2[5] = 0x18;
fvf_array_2[6] = 0x10;
fvf_array_2[7] = 0x1C;
fvf_array_2[8] = 0x4;
fvf_array_2[9] = 0x10;
fvf_array_2[10] = 0x8;
fvf_array_2[11] = 0x14;
fvf_array_2[12] = 0x10;
fvf_array_2[13] = 0x1C;
fvf_array_2[14] = 0x14;
fvf_array_2[15] = 0x20;

fn get_fvf(u32 dat_fvf)
{
    return (dat_fvf & 0xff0) << 4 | dat_fvf >> 8 & 0x30 | dat_fvf & 0xf;
};

fn get_vertex_size_from_fvf(u32 fvf)
{
  return fvf_array_0[fvf >> 0xc & 0xf] + fvf_array_0[fvf >> 8 & 0xf] + fvf_array_1[fvf >> 4 & 7] +
      fvf_array_2[fvf & 0xf];
};

struct Vertex<auto dat_fvf> {
  u32 FVF = get_fvf(dat_fvf);
  u32 vertex_size = get_vertex_size_from_fvf(FVF);
  u32 used_bytes = 0;
  if (FVF & 1){
    used_bytes += sizeof(float)*3;
    float x,y,z;
  }
  if (FVF & 2){
    used_bytes += 4;
    u32 group;
  }
  if (FVF & 4){
    used_bytes += sizeof(float)*3;
    float normal_x,normal_y,normal_z;
  }
  float data[(vertex_size-used_bytes)/4];
};

fn compute_str_len_plus_one(u32 address){
  u32 counter = 0;
  bool found = false;
  while (!found){
    u8 curr_char @ address + counter;
    if (curr_char == 0){
      found = true;
    }
    
    counter += 1;
  }
  
  return counter;
};

fn read_u32(u32 address) {
    u32 value @ address;

    return value;
};

fn get_some_size(u32 address, u32 sub_1_0x52){
  u32 iVar3 = 0;
  u32 iVar5 = 0;
  u32 iVar6 = 0;
  u32 iVar7 = 0;
  u32 local_c = 0;
  
  std::print("address: {}", address);
  std::print("sub_1_0x52: {}", sub_1_0x52);
  
  if (1 < sub_1_0x52){
    s32 iVar4 = (sub_1_0x52 - 2 >> 1) + 1;
    std::print("iVar4: {}", iVar4);
    
    local_c = iVar4 * 2;
    std::print("local_c: {}", local_c);
      
    u32 piVar1 = address + 0x2C;
      
    
    while (true){
      std::print("--------- iVar4: {} ---------", iVar4);
      u32 v3 @ (piVar1 + 0xC * 4);
      iVar3 += v3;
      std::print("iVar3: {}", iVar3);
        
      u32 v5 @ (piVar1 - 4);
      iVar5 += v5;
      std::print("iVar5: {}", iVar5);
        
      u32 v6 @ piVar1;
      iVar6 += v6;
      std::print("iVar6: {}", iVar6);
        
      u32 v7 @ (piVar1 + 0xB * 4);
      iVar7 += v7;
      std::print("iVar7 : {}", iVar7);
        
      piVar1 += 0x60;
        
      iVar4 -= 1;
      if (iVar4 <= 0){
        break;
      }
    }
  }
  
  u32 iVar4 = 0;
  u32 local_18;
  if (local_c < sub_1_0x52){
    local_18 = read_u32(address + 0x28 + local_c*6*8);
    iVar4 = read_u32(address + 0x2C + local_c*6*8);
  }
  
  local_18 += iVar7 + iVar5;
  iVar4 += iVar3 + iVar6;
  
  u32 size = iVar4 * 0x10 + local_18 * 0x18;
  
  std::print("{}", size);
  
  return size;
};

struct String {
  char string[compute_str_len_plus_one($)];
};

// Geometry Chunk Header (0x54 bytes)
// class_flags bits:
//   0x01 = HAS_SKELETON - Model has bone/skeleton data
//   0x08 = HAS_ATTACHMENT_DATA - Has attachment points data (f0x52 section)
//   0x20 = HAS_EMBEDDED_ANIMATION - Uses vertex animation (morph targets) instead of external skeletal animation
//   0x100 = Unknown
struct GeometryChunkHeader {
  u32 type_marker;           // 0x00: Always 0x26
  u32 unknown_04;            // 0x04: Unknown
  s32 class_flags;           // 0x08: Model type flags (see above)
  u32 model_hash_0;          // 0x0C: First model hash (for animation matching)
  u32 model_hash_1;          // 0x10: Second model hash
  u8 unknown_14;             // 0x14-0x17: Unknown bytes
  u8 unknown_15;
  u8 unknown_16;
  u8 unknown_17;
  u8 pixel_shader_count;     // 0x18: Number of pixel shaders
  u8 extra_texture_count;    // 0x19: Additional texture struct count (UnknownTexStruct1)
  u8 shader_string_count;    // 0x1A: Number of shader/material strings
  u8 unknown_1B;             // 0x1B: Unknown
  u8 material_count;         // 0x1C: Number of materials
  u8 extra_material_count;   // 0x1D: Extra material data count
  u8 unknown_1E;             // 0x1E: Unknown data count
  u8 unknown_1F;             // 0x1F: Unknown
  u32 has_extra_uvs;         // 0x20: Non-zero if extra UV data present
  u32 unknown_24;            // 0x24: Unknown
  u32 bounding_data_0;       // 0x28: Bounding sphere/box data
  u32 bounding_data_1;       // 0x2C: Bounding sphere/box data
  u8 bone_struct_count;      // 0x30: Number of 0x1C-byte bone structures
  u8 padding_31[3];          // 0x31-0x33: Padding
  u32 trailing_data_size;    // 0x34: Size of trailing unknown data
  u32 unknown_38;            // 0x38: Unknown
  u32 unknown_3C;            // 0x3C: Unknown
  u32 unknown_40;            // 0x40: Unknown
  u32 submesh_count;         // 0x44: Number of geometry submeshes
  u32 extra_data_count;      // 0x48: Count for f0x48_data entries
  u16 collision_mesh_count;  // 0x4C: Number of collision meshes
  u8 padding_4E[2];          // 0x4E: Padding
  u16 bone_attachment_count; // 0x50: Count of SomeStruct2 bone attachments
  u16 attachment_data_count; // 0x52: Count of attachment data (if flag 0x08)
};

struct Chunkfa1_sub1 {
  u32 some_type_maybe; // always 0x26? It's also checked for this value in the source.
  u32 f0x4;
  s32 f0x8;
  u32 f0xC;
  u32 f0x10;
  u32 f0x14;
  u8 some_num0; // Num pixel shaders?
  u8 f0x19;
  u8 f0x1a;
  u8 f0x1b;
  u8 some_num1;
  u8 f0x1d;
  u8 f0x1e;
  u8 f0x1f;
  u32 f0x20;
  u32 f0x24;
  u32 magic_num0;
  u32 animation_count;
  u8 num_some_struct; // the structs have size 0x1c
  u8 f0x31[3];
  u32 f0x34;
  u32 f0x38;
  u32 f0x3C;
  u32 f0x40;
  u32 num_models;
  u32 f0x48;
  u16 f0x4C;
  u8 f0x4E[2];
  u16 num_some_struct2;
  u16 f0x52;
};

// Geometry Submesh
// Contains vertex and index data for one submesh of the model.
// LOD (Level of Detail) indices: LOD0 = highest detail, LOD2 = lowest detail
// If LOD counts match, only one set of indices is stored.
struct geometry_sub_chunk {
  u32 submesh_id;              // Submesh identifier
  u32 index_count_lod0;        // Index count for LOD 0 (highest detail)
  u32 index_count_lod1;        // Index count for LOD 1
  u32 index_count_lod2;        // Index count for LOD 2 (lowest detail)
  u32 vertex_count;            // Number of vertices
  u32 vertex_format;           // FVF (Flexible Vertex Format) - determines vertex components
  u32 bone_group_count;        // Number of bone groups for skinning
  u32 bone_ref_count;          // Total bone references
  u32 triangle_group_count;    // Number of triangle groups (for material assignment)

  // Calculate total index count (only stores unique LOD indices)
  u32 total_index_count = index_count_lod0 +
      (index_count_lod0 != index_count_lod1 ? index_count_lod1 : 0) +
      (index_count_lod1 != index_count_lod2 ? index_count_lod2 : 0);

  u16 indices[total_index_count];
  Vertex<vertex_format> vertices[vertex_count];

  // Trailing data: bone groups, bone refs, triangle groups
  u8 trailing_data[(bone_group_count + bone_ref_count + triangle_group_count * 3) * 4];
};

struct InteractiveModelMaybe {
  u32 num_indices;
  u32 num_vertices;
  u16 indices[num_indices];
  Vertex<1> vertices[num_vertices];
};

u32 g_class_flags;
u32 g_header_address;
u32 g_chunk_size;

// Embedded Animation Data (Morph Targets / Vertex Animation)
// This structure is present when class_flags & 0x20 (HAS_EMBEDDED_ANIMATION) is set.
// Models with this flag use vertex animation (morph targets) instead of external
// skeletal animation files (BB9/FA1). The morph targets deform the mesh directly.
//
// anim_flags bits:
//   0x02 = Has compressed vertex deltas
//   0x40 = UV animation uses morph_target_count instead of uv_anim_frame_count
//   0x80000000 = Unknown (usually set)
struct EmbeddedAnimationEntry {
    // Header boundary check
    if (g_header_address + g_chunk_size < addressof($) + 0x2E) {
      // Cannot parse - not enough data
    }

    u32 keyframe_data_0_count; // 0x00: Count for keyframe data section 0
    u32 keyframe_data_1_count; // 0x04: Count for keyframe data section 1
    u32 unknown_08;            // 0x08: Unknown
    u32 anim_flags;            // 0x0C: Animation flags (see above)
    u16 total_frame_count;     // 0x10: Total frames in animation
    u8 unknown_12;             // 0x12: Unknown
    u8 bone_weights_per_vert;  // 0x13: Number of bone weights per vertex
    u16 morph_target_count;    // 0x14: Number of morph target keyframes
    u32 compressed_data_size;  // 0x16: Size of compressed animation data
    u32 uv_anim_frame_count;   // 0x1A: UV animation frame count
    u32 position_delta_count;  // 0x1E: Position delta keyframe count
    u16 unknown_22;            // 0x22: Unknown
    u16 rotation_key_count;    // 0x24: Rotation keyframe count
    u16 scale_key_count;       // 0x26: Scale keyframe count
    u16 base_vertex_count;     // 0x28: Base pose vertex count
    u32 extra_data_size;       // 0x2A: Extra animation data size

    // Calculate data section size
    u32 morph_count = morph_target_count;
    u32 vertex_delta_count = 0;
    if ((anim_flags & 2) == 0) {
      vertex_delta_count = morph_count - base_vertex_count;
    }
    u32 uv_count = morph_count;
    if ((anim_flags & 0x40) == 0) {
      uv_count = uv_anim_frame_count;
    }

    // res0 = combined keyframe metadata size
    u32 res0 = (scale_key_count + rotation_key_count) * 2;
    res0 += unknown_22;
    res0 += keyframe_data_1_count;
    res0 += uv_count;
    res0 += keyframe_data_0_count;

    // res1 = vertex delta data size (9 bytes per delta)
    u32 res1 = (vertex_delta_count + position_delta_count * 2) * 9;

    // res2 = total variable section size
    u32 res2 = res1 + res0 * 2 + extra_data_size + compressed_data_size;

    // res3 = per-keyframe bone weight data
    u32 res3 = (bone_weights_per_vert * 8 + 0xC) * morph_count;

    // Total data size
    u32 total_data_size = res3 + res2 * 2;

    u8 animation_data[total_data_size];
};

// To get file hash from name do:
// (id0 - 0xff00ff) + (id2 * 0xff00);
struct FileName{
  u16 id0;
  u16 id1;
  u16 unknown;
};

struct UnknownTexStruct0{
  u8 using_no_cull; // 0 if cull enabled, 1 if no culling enabled.
  u8 f0x1;
  u32 f0x2;
  u8 pixel_shader_id;
  u8 num_uv_coords_to_use;
};

struct UnknownTexStruct1{
  u16 some_flags0; // 0x60A converted to 0x622
  u16 some_flags1; // 0x600 converted to 0x600
  u8 f0x4;   
  u8 f0x5;
  u8 f0x6;
  u8 f0x7;
  u8 f0x8;
};

struct TextureAndVertexShader<auto num_textures, auto num1, auto f0x20> {
  UnknownTexStruct0 uts0[num_textures];
  u16 flags0[num1];
  u8 tex_array[num1];
  u8 zeros[num1*4];
  u8 blend_state[num1]; // 0 is no blend/no transparency, 6/7 is reversed alpha? 8 ir normal alpha. 3 is another type of reversed alpha? it shows more of the partt where alpha is 0.
                        // So if flag 0 then textures alpha component is ignored and the texture is non-seethrough.
                        // if flag set to 6 or 7 the alpha is reversed. So alpha=1 is fully transparent, alpha=0 is still slightly transparent. the transparent part is darker than when flag is set to 3.
                        // if flag set to 8 then the alpha component is normal so alpha=1 is non-transparent, alpha=0 is fully transparent.
  u8 texture_index_UV_mapping_maybe[num1];
  u8 u1[(-(f0x20 != 0) & num1)];
};

struct f0x48_data
{
  u32 count;
  u8 data[count*8];
};

struct SomeStruct2{
  u8 unknown[8];
  u32 f0x8;
  u32 f0xC;
  u32 f0x10;
  u32 f0x14;
  
  u32 data_size = f0x8 * 7 + (f0xC + f0x10 + f0x14)*8;
  u8 data[data_size];
};

struct GeometryChunk {
  u32 chunk_id;
  u32 chunk_size;

  // Store globals for nested struct calculations
  g_chunk_size = chunk_size;

  // Geometry chunk header (0x54 bytes)
  GeometryChunkHeader header;
  g_header_address = addressof(header);
  g_class_flags = header.class_flags;

  // Bone structures (0x1C bytes each)
  u8 bone_structs[header.bone_struct_count * 0x1C];

  // Bone attachment structures (variable size)
  SomeStruct2 bone_attachments[header.bone_attachment_count];

  // Texture and shader configuration
  TextureAndVertexShader<header.pixel_shader_count, header.material_count, header.has_extra_uvs> material_config;

  u32 extra_bytes = 0; // Track bytes read in optional sections

  // Extra texture data (if extra_texture_count > 0)
  if (header.extra_texture_count > 0) {
      u32 puVar15 = header.extra_texture_count * 9;
      if (addressof(chunk_id) + puVar15 < addressof(chunk_id) + 8 + chunk_size) {
        u32 puVar16 = header.extra_material_count * ((header.has_extra_uvs != 0) + 3) + puVar15;
        if (addressof(chunk_id) + puVar16 < addressof(chunk_id) + 8 + chunk_size) {
          u32 _Src = puVar16 + header.shader_string_count * 8;
          if (addressof(chunk_id) + _Src < addressof(chunk_id) + 8 + chunk_size) {
            UnknownTexStruct1 extra_tex_structs[header.extra_texture_count];
            u16 extra_material_flags[header.extra_material_count];
            u8 extra_material_data[header.extra_material_count];
            u8 extra_data_padding[_Src - sizeof(extra_tex_structs) - sizeof(extra_material_flags) - sizeof(extra_material_data)];

            String shader_strings[header.shader_string_count];
            u8 unknown_1E_data[header.unknown_1E * 2 * 4];

            extra_bytes += sizeof(extra_tex_structs) + sizeof(extra_material_flags) + sizeof(extra_material_data) + sizeof(extra_data_padding) + sizeof(shader_strings) + sizeof(unknown_1E_data);
          }
          else {
            u8 fallback_data0[puVar16]; // Cannot fully parse
          }
        }
        else {
          u8 fallback_data1[puVar15]; // Cannot fully parse
        }
      }
  }

  // Embedded animation data (if HAS_EMBEDDED_ANIMATION flag is set)
  if (g_class_flags & 0x20) {
    if (g_header_address + g_chunk_size >= addressof($) + 8) {
      u32 embedded_anim_total_size;  // Total size of embedded animation section
      u32 embedded_anim_count;       // Number of animation entries
      EmbeddedAnimationEntry embedded_animations[embedded_anim_count];

      extra_bytes += 8 + sizeof(embedded_animations);
    }
  }

  // Attachment data (if HAS_ATTACHMENT_DATA flag is set)
  if ((header.class_flags & 8) >> 3 == 1) {
    u32 attachment_size = get_some_size($, header.attachment_data_count);
    u8 attachment_entries[header.attachment_data_count * 0x30];
    u8 attachment_extra_data[attachment_size];

    extra_bytes += sizeof(attachment_entries) + sizeof(attachment_extra_data);
  }

  // Geometry submeshes
  geometry_sub_chunk submeshes[header.submesh_count];

  // Collision meshes
  InteractiveModelMaybe collision_meshes[header.collision_mesh_count];

  // Extra data entries
  f0x48_data extra_data_entries[header.extra_data_count];

  // Trailing unknown data
  u8 trailing_data[header.trailing_data_size];

  // Remaining chunk data (should be empty if everything parsed correctly)
  u8 remaining_data[chunk_size - sizeof(header) - sizeof(bone_attachments) - sizeof(bone_structs) - sizeof(material_config)
     - sizeof(submeshes) - extra_bytes
     - sizeof(collision_meshes)
     - sizeof(extra_data_entries) - sizeof(trailing_data)];
};



struct FileNamesChunk {
  u32 chunk_id;
  u32 chunk_size;
  u32 num_filenames;
    u32 actual_num_filenames = std::math::min(num_filenames, (chunk_size-4) / sizeof(FileName));
  FileName filenames[actual_num_filenames];
  u8 chunk_data[chunk_size-4-sizeof(filenames)];
};

struct SomeAnimationStruct<auto anim_count> {
  u8 some_data[anim_count << 4];
  u32 loop_counter = 0;
  
};

struct ChunkFA1 {
  u32 chunk_id;
  u32 chunk_size;
  Chunkfa1_sub1 sub_1; 
  u32 unknown;
  u8 unknown_data[sub_1.f0x14 << 4];
  u8 unknown_data1[sub_1.f0x34*0x18];
  SomeAnimationStruct<sub_1.animation_count> some_anim_struct;
  u8 chunk_data[chunk_size-sizeof(sub_1)-4-sizeof(unknown_data)
  -sizeof(unknown_data1)-sizeof(some_anim_struct)];
};

struct UnknownChunk {
  u32 chunk_id;
  u32 chunk_size;
  u8 chunk_data[chunk_size];
};

struct Chunk {
 u32 chunk_id = std::mem::read_unsigned($, 4);
 if (chunk_id == 0xFA0){
   GeometryChunk geometry_chunk;
 }
 else if (chunk_id == 0xFA1){
   ChunkFA1 fa1_chunk;
 }
 else if (chunk_id == 0xFA5 || chunk_id == 0xfa6 || chunk_id == 0xfad){
   FileNamesChunk filenames_chunk;
 }
 else{
   UnknownChunk unknown_chunk;
 }
};

struct ModelFile {
  char ffna[4];
  u8 file_tpe;
  Chunk chunks[while($ < sizeof($))];
};

ModelFile modelfile @ 0;